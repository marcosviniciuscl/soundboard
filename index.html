<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="script-src 'self' 'unsafe-inline'; media-src 'self' file:;">
    <title>Soundboard - Atalhos de √Åudio</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e1e1e 0%, #2d2d2d 100%);
            color: #ffffff;
            padding: 20px;
            overflow-x: hidden;
        }
        
        /* ... (Todo o seu CSS existente) ... */
        
        .container { max-width: 1200px; margin: 0 auto; }
        header { text-align: center; margin-bottom: 30px; }
        h1 { font-size: 2.5em; margin-bottom: 10px; background: linear-gradient(45deg, #4CAF50, #2196F3); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
        .subtitle { color: #aaaaaa; font-size: 1.1em; }
        .controls { display: flex; gap: 15px; margin-bottom: 30px; flex-wrap: wrap; }
        button { padding: 12px 24px; border: none; border-radius: 8px; font-size: 1em; font-weight: bold; cursor: pointer; transition: all 0.3s ease; display: flex; align-items: center; gap: 8px; }
        button:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
        .btn-add { background: linear-gradient(135deg, #4CAF50, #45a049); color: white; }
        .btn-edit { background: linear-gradient(135deg, #f39c12, #e67e22); color: white; }
        .btn-remove { background: linear-gradient(135deg, #f44336, #da190b); color: white; }
        .btn-test { background: linear-gradient(135deg, #2196F3, #0b7dda); color: white; }
        .sounds-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 20px; margin-bottom: 20px; }
        .sound-card { background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 12px; padding: 20px; transition: all 0.3s ease; cursor: pointer; }
        .sound-card:hover { background: rgba(255, 255, 255, 0.08); border-color: #4CAF50; transform: translateY(-3px); box-shadow: 0 8px 20px rgba(76, 175, 80, 0.2); }
        .sound-card.selected { border-color: #2196F3; background: rgba(33, 150, 243, 0.1); }
        .sound-name { font-size: 1.3em; font-weight: bold; margin-bottom: 10px; color: #4CAF50; }
        .sound-hotkey { display: inline-block; background: rgba(255, 255, 255, 0.1); padding: 6px 12px; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 0.9em; margin-bottom: 8px; color: #2196F3; }
        .sound-file { font-size: 0.85em; color: #aaaaaa; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; margin-bottom: 12px; }
        .sound-details { font-size: 0.9em; color: #ccc; display: flex; justify-content: space-between; flex-wrap: wrap; gap: 10px; padding-top: 10px; border-top: 1px solid rgba(255, 255, 255, 0.1); }
        .empty-state { text-align: center; padding: 60px 20px; color: #888; }
        .empty-state-icon { font-size: 4em; margin-bottom: 20px; }
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); backdrop-filter: blur(5px); overflow-y: auto; }
        .modal-content { background: linear-gradient(135deg, #2d2d2d 0%, #1e1e1e 100%); margin: 5% auto; padding: 30px; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 16px; width: 90%; max-width: 500px; box-shadow: 0 20px 60px rgba(0,0,0,0.5); }
        .modal-header { font-size: 1.8em; margin-bottom: 25px; color: #4CAF50; }
        .form-group { margin-bottom: 20px; }
        .form-group-inline { display: flex; gap: 15px; }
        .form-group-inline > div { flex: 1; }
        label { display: block; margin-bottom: 8px; color: #aaaaaa; font-weight: 500; }
        .slider-label { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .slider-label span { color: #fff; background: rgba(255, 255, 255, 0.1); padding: 2px 8px; border-radius: 4px; font-size: 0.9em; }
        input[type="text"], input[type="number"] { width: 100%; padding: 12px; border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; background: rgba(255, 255, 255, 0.05); color: white; font-size: 1em; }
        input[type="number"] { -moz-appearance: textfield; }
        input[type="number"]::-webkit-inner-spin-button, input[type="number"]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        input[type="text"]:focus, input[type="number"]:focus { outline: none; border-color: #4CAF50; background: rgba(255, 255, 255, 0.08); }
        input[type="range"] { -webkit-appearance: none; width: 100%; height: 8px; border-radius: 5px; background: rgba(255, 255, 255, 0.1); outline: none; transition: background 0.3s; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; border-radius: 50%; background: #4CAF50; cursor: pointer; }
        input[type="range"]::-moz-range-thumb { width: 20px; height: 20px; border-radius: 50%; background: #4CAF50; cursor: pointer; }
        .form-group-check { display: flex; align-items: center; gap: 12px; }
        .form-group-check label { margin-bottom: 0; }
        input[type="checkbox"] { width: 18px; height: 18px; cursor: pointer; }
        .file-selector { display: flex; gap: 10px; align-items: center; }
        .file-name { flex: 1; padding: 12px; background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; color: #aaaaaa; }
        .modal-actions { display: flex; gap: 10px; margin-top: 25px; }
        .modal-actions button { flex: 1; }
        .info { text-align: center; padding: 15px; background: rgba(33, 150, 243, 0.1); border: 1px solid rgba(33, 150, 243, 0.3); border-radius: 8px; color: #2196F3; margin-top: 20px; }
        .close { color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer; line-height: 20px; }
        .close:hover { color: #fff; }

        /* MUDAN√áA: CSS para o seletor de √°udio */
        .audio-output-selector {
            margin-bottom: 20px;
            margin-top: 20px; /* Adicionado espa√ßo em cima */
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .audio-output-selector label {
            font-weight: bold;
            color: #aaaaaa;
            margin-bottom: 0; 
        }
        .audio-output-selector select {
            flex: 1;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            font-size: 1em;
        }

        /* MUDAN√áA: Cor de fundo das op√ß√µes do dropdown */
        .audio-output-selector select option {
            background: #2d2d2d;
            color: #ffffff;
        }

        /* MUDAN√áA: Estilos para a visualiza√ß√£o em tabela */
        .sounds-table-container {
            width: 100%;
            display: none; /* Come√ßa escondido */
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            overflow: hidden; /* Para o border-radius funcionar */
        }

        .sounds-table {
            width: 100%;
            border-collapse: collapse;
        }

        .sounds-table th, .sounds-table td {
            padding: 15px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .sounds-table th {
            background: rgba(76, 175, 80, 0.1);
            color: #4CAF50;
            font-size: 0.9em;
            text-transform: uppercase;
        }

        .sounds-table tr {
            transition: background-color 0.2s ease;
            cursor: pointer;
        }

        .sounds-table tr:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .sounds-table tr:last-child td {
            border-bottom: none;
        }
        
        .sounds-table tr.selected {
            border-color: #2196F3; /* Mesmo que o card */
            background: rgba(33, 150, 243, 0.1); 
        }

        .sounds-table .sound-file {
            max-width: 200px; /* Limita a largura do nome do arquivo */
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .sounds-table .sound-hotkey {
            font-size: 1em; /* Ajusta o tamanho do atalho na tabela */
        }

        .sounds-table tbody tr {
            cursor: grab; /* Indica que a linha pode ser arrastada */
        }
        .sounds-table tbody tr:active {
            cursor: grabbing; /* Ao arrastar */
        }

        .sortable-ghost {
            opacity: 0.4;
            background: #444;
            border-style: dashed;
        }

        .sound-stats {
            font-size: 0.8em;
            color: #999;
            padding-top: 8px;
            margin-top: 8px;
            border-top: 1px dashed rgba(255, 255, 255, 0.1);
        }
        .sound-stats span {
            display: block; /* Fica um em cima do outro */
            line-height: 1.4; /* Espa√ßamento */
        }

        /* MUDAN√áA: Estilos para as novas colunas da TABELA */
        .sounds-table .col-plays {
            width: 90px;
            text-align: center;
        }
        .sounds-table .col-last-played {
            width: 160px;
            font-size: 0.9em;
            color: #aaa;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üéµ Hahaha</h1>
            <p class="subtitle">Atalhos de √°udio personalizados</p>
        </header>

        <div class="controls">
            <button class="btn-add" onclick="openAddModal()">‚ûï Adicionar √Åudio</button>
            <button class="btn-edit" onclick="openEditModal()">‚úèÔ∏è Editar Selecionado</button>
            <button class="btn-remove" onclick="removeSound()">üóëÔ∏è Remover Selecionado</button>
            <button class="btn-test" onclick="testSelected()">‚ñ∂Ô∏è Testar Som</button>
            <button id="viewToggleButton" class="btn-test" onclick="toggleView()" style="min-width: 60px; justify-content: center; font-size: 1.5em; padding: 10px;">
                ‚ò∞
            </button>
        </div>

        <div id="soundsContainer" class="sounds-grid">
            </div>

        <div id="tableOrderInfo" class"info" style="display: none; margin-bottom: 20px; background: rgba(33, 150, 243, 0.1); border: 1px solid rgba(33, 150, 243, 0.3); border-radius: 8px; color: #2196F3; padding: 15px; text-align: center;">
            üí° Arraste e solte as linhas da tabela para reordenar. Os <b>10 primeiros</b> sons aparecer√£o no menu de acesso r√°pido (Ctrl+Shift+Espa√ßo).
        </div>
        
        <div id="tableContainer" class="sounds-table-container">
            </div>


        <div class="global-settings-container">
            <div class="audio-output-selector">
                <label for="audioOutputSelect">üîä Sa√≠da de √Åudio:</label>
                <select id="audioOutputSelect" onchange="saveGlobalSettings()">
                    <option value="default">Padr√£o do Sistema</option>
                </select>
            </div>
            
            <div class="audio-output-selector" style="margin-top: -10px;">
                <input type="checkbox" id="volumeBoostCheck" onchange="saveGlobalSettings()" style="width: 20px; height: 20px;">
                <label for="volumeBoostCheck" style="flex: 1; cursor: pointer;">‚ö° Ativar "Boost" de Volume (Sistema)</label>
                
                <input type="number" id="volumeBoostAmount" value="20" min="1" max="100" onchange="saveGlobalSettings()" style="width: 70px; padding: 10px;">
                <label for="volumeBoostAmount" style="margin-right: 5px;">+%</label>
            </div>
        </div>

        <div class="info">
            üí° Duplo clique para testar ‚Ä¢ Atalhos funcionam mesmo com a janela minimizada
        </div>
    </div>


    <div id="addModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeAddModal()">&times;</span>
            <h2 class="modal-header" id="modalTitle">Adicionar Novo Som</h2>
            <input type="hidden" id="originalSoundName" value="">
            <div class="form-group">
                <label>Nome do Som:</label>
                <input type="text" id="soundName" placeholder="Ex: Risada do Chaves">
            </div>
            <div class="form-group">
                <label>Atalho:</label>
                <input type="text" id="soundHotkey" placeholder="Clique aqui e pressione as teclas..." readonly style="cursor: pointer;">
                <small style="color: #888; display: block; margin-top: 5px;">
                    Use Ctrl, Shift, Alt.
                </small>
                <button class="btn-test" onclick="clearHotkey()" style="margin-top: 8px; width: 100%;">
                    üîÑ Limpar Atalho
                </button>
            </div>
            <div class="form-group">
                <label>Arquivo de √Åudio:</label>
                <div class="file-selector">
                    <div class="file-name" id="fileName">Nenhum arquivo selecionado</div>
                    <button class="btn-test" onclick="selectFile()" style="flex: 0 0 auto;">
                        üìÅ Escolher
                    </button>
                </div>
                <small id="audioDuration" style="color: #888; display: block; margin-top: 5px; min-height: 1.2em;"></small>
            </div>
            <div class="form-group form-group-inline">
                <div>
                    <label>In√≠cio (segundos):</label>
                    <input type="number" id="soundStartTime" min="0" step="0.1" value="0">
                </div>
                <div>
                    <label>Fim (segundos):</label>
                    <input type="number" id="soundEndTime" min="0" step="0.1" value="0">
                </div>
            </div>
             <small style="color: #888; display: block; margin-top: -15px; margin-bottom: 15px;">
                Deixe "Fim" como 0 para tocar at√© o final.
            </small>
            <div class="form-group">
                <div class="slider-label">
                    <label>Volume:</label>
                    <span id="volumeValue">100%</span>
                </div>
                <input type="range" id="soundVolume" min="0" max="1" step="0.01" value="1" oninput="updateSliderLabels()">
            </div>
            <div class="form-group">
                 <div class="slider-label">
                    <label>Velocidade:</label>
                    <span id="speedValue">1.0x</span>
                </div>
                <input type="range" id="soundSpeed" min="0.5" max="2" step="0.1" value="1" oninput="updateSliderLabels()">
            </div>
            <div class="form-group form-group-check">
                <input type="checkbox" id="soundLoop">
                <label for="soundLoop">Repetir (Loop)</label>
            </div>
            
            <div class="modal-actions">
                <button class="btn-add" onclick="saveSound()">üíæ Salvar</button>
                <button class="btn-test" type="button" onclick="previewSound(event)">‚ñ∂Ô∏è Pr√©via</button>
                <button class="btn-remove" type="button" onclick="closeAddModal()">‚ùå Cancelar</button>
            </div>
        </div>
    </div>


    <script>
        const { ipcRenderer } = require('electron');
        const path = require('path');
        const Sortable = require('sortablejs');

        let config = { settings: { audioDevice: 'default', soundOrder: [] }, sounds: {} };
        
        let selectedSound = null;
        let selectedFilePath = null;
        let currentAudio = null;
        let currentPlayingSoundName = null;
        let previewAudio = null;
        let previewStopTimer = null;
        let isCapturingHotkey = false;
        let capturedKeys = new Set();
        let stopAudioTimer = null;
        let currentView = 'grid';
        let originalSystemVolume = null;
        let isSystemVolumeBoosted = false;
        let sortableInstance = null;


        async function loadConfig() {
            config = await ipcRenderer.invoke('load-config');

            if (!config.settings) config.settings = { audioDevice: 'default' };
            if (!config.sounds) config.sounds = {};


            const soundKeys = Object.keys(config.sounds);

            if (!config.settings.soundOrder) {
                config.settings.soundOrder = soundKeys;
                console.log('Array soundOrder criado pela primeira vez.');
            } else {
                config.settings.soundOrder = config.settings.soundOrder.filter(name => config.sounds[name]);
                
                soundKeys.forEach(name => {
                    if (!config.settings.soundOrder.includes(name)) {
                        config.settings.soundOrder.push(name);
                    }
                });
            }

            await loadAudioDevices();
            const savedDevice = config.settings.audioDevice || 'default';
            document.getElementById('audioOutputSelect').value = savedDevice;

            // --- MUDAN√áA: Carrega as novas configura√ß√µes ---
            document.getElementById('volumeBoostCheck').checked = config.settings.volumeBoostEnabled || false;
            document.getElementById('volumeBoostAmount').value = config.settings.volumeBoostAmount || 20;
            // --- Fim da mudan√ßa ---

            renderSounds();
        }

        async function saveConfig() {
            await ipcRenderer.invoke('save-config', config);
            ipcRenderer.send('config-updated', config);
        }

        function toggleView() {
            const gridContainer = document.getElementById('soundsContainer');
            const tableContainer = document.getElementById('tableContainer');
            const toggleButton = document.getElementById('viewToggleButton');
            const tableInfo = document.getElementById('tableOrderInfo');

            if (currentView === 'grid') {
                currentView = 'table';
                toggleButton.innerHTML = "‚ñ¶";
                gridContainer.style.display = 'none';
                tableContainer.style.display = 'block';
                tableInfo.style.display = 'block';
            } else {
                currentView = 'grid';
                toggleButton.innerHTML = "‚ò∞"; // <<< MUDAN√áA: √çcone de Tabela
                gridContainer.style.display = 'grid'; // Use 'grid' para layout correto
                tableContainer.style.display = 'none';
                tableInfo.style.display = 'none';
            }
            
            renderSounds();
        }

        async function loadAudioDevices() {
            const select = document.getElementById('audioOutputSelect');
            select.innerHTML = '<option value="default">Padr√£o do Sistema</option>'; 

            try {
                await navigator.mediaDevices.getUserMedia({ audio: true });
            } catch (err) {
                console.warn('Permiss√£o de √°udio negada. Os nomes dos dispositivos podem n√£o aparecer.');
                alert('Por favor, permita o acesso ao microfone para listar os dispositivos de √°udio.');
            }

            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const audioDevices = devices.filter(device => device.kind === 'audiooutput');

                audioDevices.forEach(device => {
                    if (device.deviceId === 'default' || device.deviceId === 'communications') return;
                    
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.textContent = device.label || `Dispositivo ${select.options.length}`;
                    select.appendChild(option);
                });
            } catch (err) {
                console.error('Erro ao listar dispositivos de √°udio:', err);
            }
        }

        async function saveGlobalSettings() {
            config.settings.audioDevice = document.getElementById('audioOutputSelect').value;
            config.settings.volumeBoostEnabled = document.getElementById('volumeBoostCheck').checked;
            config.settings.volumeBoostAmount = parseInt(document.getElementById('volumeBoostAmount').value) || 20;
            
            await saveConfig();
        }

        async function saveAudioDevice() {
            // const selectedDeviceId = document.getElementById('audioOutputSelect').value;
            // config.settings.audioDevice = selectedDeviceId;
            // await saveConfig();
            await saveGlobalSettings(); // MUDAN√áA: Apenas chama a fun√ß√£o principal
        }

        function loadAudioDuration(filePath, callback) {
            const durationEl = document.getElementById('audioDuration');
            durationEl.textContent = 'Carregando dura√ß√£o...';
            
            try {
                const audio = new Audio(filePath);
                audio.onloadedmetadata = () => {
                    const duration = audio.duration;
                    const minutes = Math.floor(duration / 60);
                    const seconds = Math.floor(duration % 60);
                    durationEl.textContent = `Dura√ß√£o Total: ${minutes}:${seconds.toString().padStart(2, '0')} (${duration.toFixed(2)}s)`;
                    if (callback) callback(duration); // Chama o callback com a dura√ß√£o
                };
                audio.onerror = () => {
                    durationEl.textContent = 'Erro ao carregar o arquivo de √°udio.';
                };
            } catch (err) {
                durationEl.textContent = 'Erro ao carregar o √°udio.';
                console.error(err);
            }
        }

        async function previewSound(event) {
            event.preventDefault(); // Impede qualquer comportamento padr√£o do bot√£o
            const button = event.target.closest('button'); 

            // 1. Se o preview j√° est√° tocando, pare-o
            if (previewAudio) {
                previewAudio.pause();
                previewAudio.currentTime = 0;
                previewAudio.src = '';
                previewAudio = null;
                if (previewStopTimer) clearTimeout(previewStopTimer);
                previewStopTimer = null;
                button.innerHTML = "‚ñ∂Ô∏è Pr√©via";

                await restoreVolumeBoost();
                return;
            }

            // 2. Verifique se um arquivo foi selecionado
            if (!selectedFilePath) {
                alert('Por favor, selecione um arquivo de √°udio primeiro!');
                return;
            }

            // 3. Pare qualquer √°udio principal que esteja tocando
            if (currentAudio) {
                currentAudio.pause();
                currentAudio.currentTime = 0;
                currentAudio.src = ''; 
                currentAudio = null;
                currentPlayingSoundName = null;
                if (stopAudioTimer) {
                    clearTimeout(stopAudioTimer);
                    stopAudioTimer = null;
                }
            }

            await restoreVolumeBoost();
            
            // 4. Pegue todas as configura√ß√µes do modal
            const volume = parseFloat(document.getElementById('soundVolume').value);
            const speed = parseFloat(document.getElementById('soundSpeed').value);
            const loop = document.getElementById('soundLoop').checked;
            const startTime = parseFloat(document.getElementById('soundStartTime').value) || 0;
            const endTime = parseFloat(document.getElementById('soundEndTime').value) || 0;

            try {
                await applyVolumeBoost();

                // 5. Crie e configure o √°udio de preview
                previewAudio = new Audio(selectedFilePath);
                previewAudio.volume = volume;
                previewAudio.playbackRate = speed;
                previewAudio.loop = loop;
                previewAudio.currentTime = startTime;

                // 6. Defina o dispositivo de sa√≠da de √°udio (o mesmo selecionado no dropdown principal)
                const deviceId = document.getElementById('audioOutputSelect').value || 'default';
                if (deviceId !== 'default') {
                    try {
                        await previewAudio.setSinkId(deviceId);
                    } catch (err) {
                        console.error('Falha ao definir sa√≠da de √°udio para pr√©via:', err);
                        alert('Falha ao definir sa√≠da de √°udio para pr√©via.');
                    }
                }

                // 7. Toque o √°udio
                await previewAudio.play();
                button.innerHTML = "‚èπÔ∏è Parar"; // Mude o texto do bot√£o

                // 8. Limpe quando o √°udio terminar
                previewAudio.addEventListener('ended', () => {
                    button.innerHTML = "‚ñ∂Ô∏è Pr√©via";
                    previewAudio = null;
                    restoreVolumeBoost();
                });
                
                // 9. L√≥gica para 'endTime' (copiada de playSound)
                if (endTime > startTime && !previewAudio.loop) {
                    const durationInMs = (endTime - startTime) * 1000 / previewAudio.playbackRate;
                    previewStopTimer = setTimeout(() => {
                        if (previewAudio) {
                            previewAudio.pause();
                            previewAudio.currentTime = startTime;
                            // Dispara o evento 'ended' manualmente para resetar o bot√£o
                            previewAudio.dispatchEvent(new Event('ended')); 
                        }
                    }, durationInMs);
                }

                if (endTime > startTime && previewAudio.loop) {
                    previewAudio.addEventListener('timeupdate', function() {
                        if (this.currentTime >= endTime) {
                            this.currentTime = startTime;
                        }
                    });
                }
                
            } catch (err) {
                console.error('Erro ao reproduzir pr√©via:', err);
                alert('Erro ao reproduzir a pr√©via. Verifique o arquivo.');
                if (previewAudio) previewAudio = null;
                button.innerHTML = "‚ñ∂Ô∏è Pr√©via";
                restoreVolumeBoost();
            }
        }

        /**
         * Inicializa o "arrastar e soltar" na tabela
         */
        function initTableSortable() {
            // Destr√≥i qualquer inst√¢ncia antiga
            if (sortableInstance) {
                sortableInstance.destroy();
                sortableInstance = null;
            }
            
            const tableBody = document.querySelector('.sounds-table tbody');
            if (!tableBody) return; // Sai se a tabela n√£o estiver vis√≠vel

            sortableInstance = Sortable.create(tableBody, {
                ghostClass: 'sortable-ghost', // Classe CSS do "fantasma"
                animation: 150,
                // Chamado quando voc√™ solta uma linha
                onEnd: async (evt) => {
                    // Pega o nome do som que foi movido
                    // (Vamos busc√°-lo do nosso array de ordem, usando o √≠ndice antigo)
                    const movedSoundName = config.settings.soundOrder.splice(evt.oldIndex, 1)[0];
                    
                    // Insere o nome na nova posi√ß√£o do array
                    config.settings.soundOrder.splice(evt.newIndex, 0, movedSoundName);
                    
                    // Salva a nova ordem no arquivo de config
                    await saveConfig();
                }
            });
        }


        /**
         * Aumenta o volume do sistema se a op√ß√£o estiver marcada.
         */
        async function applyVolumeBoost() {
            const boostCheck = document.getElementById('volumeBoostCheck').checked;
            
            // S√≥ executa se o boost estiver ligado E o volume n√£o estiver j√° aumentado
            if (boostCheck && !isSystemVolumeBoosted) {
                try {
                    const currentVolume = await ipcRenderer.invoke('get-system-volume');
                    if (currentVolume === null) return; // Falha ao obter

                    originalSystemVolume = currentVolume; // Salva o volume original
                    
                    const boostAmount = parseInt(document.getElementById('volumeBoostAmount').value) || 20;
                    let newVolume = currentVolume + boostAmount;
                    if (newVolume > 100) newVolume = 100; // Limita em 100%

                    await ipcRenderer.invoke('set-system-volume', newVolume);
                    isSystemVolumeBoosted = true; // Marca que o volume foi aumentado
                } catch (err) {
                    console.error('Falha ao aplicar boost de volume:', err);
                }
            }
        }

        /**
         * Restaura o volume do sistema ao seu valor original.
         */
        async function restoreVolumeBoost() {
            // S√≥ executa se o volume estiver aumentado e tivermos um valor original
            if (isSystemVolumeBoosted && originalSystemVolume !== null) {
                try {
                    await ipcRenderer.invoke('set-system-volume', originalSystemVolume);
                    originalSystemVolume = null; // Limpa o valor
                    isSystemVolumeBoosted = false; // Marca que o volume foi restaurado
                } catch (err) {
                    console.error('Falha ao restaurar volume:', err);
                }
            }
        }


        function renderSounds() {
            const gridContainer = document.getElementById('soundsContainer');
            const tableContainer = document.getElementById('tableContainer');

            if (sortableInstance) {
                sortableInstance.destroy();
                sortableInstance = null; // Impede futuras chamadas "zumbis"
            }

            // --- MUDAN√áA PRINCIPAL: Usa o array 'soundOrder' como fonte da verdade ---
            const soundNamesInOrder = config.settings.soundOrder || [];

            // 1. L√≥gica do Estado Vazio
            if (soundNamesInOrder.length === 0) {
                const emptyHtml = `... (seu HTML de estado vazio) ...`;
                gridContainer.innerHTML = emptyHtml;
                tableContainer.innerHTML = emptyHtml; // Mostra nas duas views
                // if (sortableInstance) sortableInstance.destroy(); // Destr√≥i o sortable
                return;
            }

            // 2. Limpa containers
            gridContainer.innerHTML = '';
            tableContainer.innerHTML = '';

            // 3. Renderiza a view correta
            if (currentView === 'grid') {
                // --- Renderiza a GRADE (usando a nova ordem) ---
                // if (sortableInstance) sortableInstance.destroy(); // S√≥ ativa sortable na tabela
                
                soundNamesInOrder.forEach(name => {
                    const data = config.sounds[name];
                    if (!data) return; // Som √≥rf√£o, pula
                    
                    const card = document.createElement('div');
                    card.className = 'sound-card';
                    if (selectedSound === name) {
                        card.classList.add('selected');
                    }
                    
                    const fileName = path.basename(data.path);
                    const volume = (data.volume !== undefined ? data.volume : 1) * 100;
                    const speed = data.speed !== undefined ? data.speed : 1;
                    const loop = data.loop || false;
                    const startTime = data.startTime || 0;
                    const endTime = data.endTime || 0;
                    const timeText = (endTime > startTime) ? `${startTime.toFixed(1)}s - ${endTime.toFixed(1)}s` : 'Completo';
                    const playCount = data.playCount || 0;
                    const lastPlayed = formatLastPlayed(data.lastPlayed);

                    card.innerHTML = `
                        <div class="sound-name">${name}</div>
                        <div class="sound-hotkey">‚å®Ô∏è ${data.hotkey}</div>
                        <div class="sound-file">üìÑ ${fileName}</div>
                        <div class="sound-details">
                            <span>üîä ${volume.toFixed(0)}%</span>
                            <span>‚è© ${speed.toFixed(1)}x</span>
                            <span>${loop ? 'üîÑ Repetir' : '‚ñ∂Ô∏è Tocar 1x'}</span>
                        </div>
                        <div class="sound-details" style="border-top: none; padding-top: 5px;">
                             <span>‚è±Ô∏è ${timeText}</span>
                        </div>
                        <div class="sound-stats">
                            <span>‚ñ∂Ô∏è ${playCount} execu√ß√µes</span>
                            <span>üïí ${lastPlayed}</span>
                        </div>
                    `;
                    card.onclick = () => selectSoundCard(name);
                    gridContainer.appendChild(card);
                });

            } else {
                // --- Renderiza a TABELA (usando a nova ordem) ---
                let tableHtml = `
                    <table class="sounds-table">
                        <thead>
                            <tr>
                                <th>Nome</th>
                                <th>Atalho</th>
                                <th>Arquivo</th>
                                <th>Volume</th>
                                <th>Velocidade</th>
                                <th>Loop</th>
                                <th class="col-plays">Execu√ß√µes</th>
                                <th class="col-last-played">√öltima Vez</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

                soundNamesInOrder.forEach(name => {
                    const data = config.sounds[name];
                    if (!data) return;

                    const isSelected = (selectedSound === name) ? 'selected' : '';
                    const fileName = path.basename(data.path);
                    const volume = (data.volume !== undefined ? data.volume : 1) * 100;
                    const speed = data.speed !== undefined ? data.speed : 1;
                    const loop = data.loop ? 'Sim' : 'N√£o';
                    const playCount = data.playCount || 0;
                    const lastPlayed = formatLastPlayed(data.lastPlayed);

                    // MUDAN√áA: O 'ondblclick' foi removido da tag <tr>
                    tableHtml += `
                        <tr class="${isSelected}" 
                            onclick="selectSoundCard(${JSON.stringify(name)})">
                            
                            <td>${name}</td>
                            <td><span class="sound-hotkey">${data.hotkey}</span></td>
                            <td class="sound-file" title="${data.path}">${fileName}</td>
                            <td>${volume.toFixed(0)}%</td>
                            <td>${speed.toFixed(1)}x</td>
                            <td>${loop}</td>
                            <td class="col-plays">${playCount}</td>
                            <td class="col-last-played">${lastPlayed}</td>
                        </tr>
                    `;
                });

                tableHtml += `</tbody></table>`;
                tableContainer.innerHTML = tableHtml;
                
                // MUDAN√áA: Inicializa o "arrastar e soltar" na tabela
                initTableSortable();
            }
        }



        function selectSoundCard(name) {
            selectedSound = name;
            renderSounds();
            playSound(name);
        }

        function updateSliderLabels() {
            try {
                const vol = document.getElementById('soundVolume').value;
                document.getElementById('volumeValue').textContent = `${Math.round(vol * 100)}%`;
                const speed = document.getElementById('soundSpeed').value;
                document.getElementById('speedValue').textContent = `${parseFloat(speed).toFixed(1)}x`;
            } catch (e) {}
        }


        function openAddModal() {
            document.getElementById('modalTitle').textContent = 'Adicionar Novo Som';
            document.getElementById('originalSoundName').value = ''; 
            document.getElementById('soundName').value = '';
            document.getElementById('soundHotkey').value = '';
            document.getElementById('fileName').textContent = 'Nenhum arquivo selecionado';
            document.getElementById('audioDuration').textContent = '';
            selectedFilePath = null;
            document.getElementById('soundVolume').value = 1;
            document.getElementById('soundSpeed').value = 1;
            document.getElementById('soundLoop').checked = false;
            document.getElementById('soundStartTime').value = 0;
            document.getElementById('soundEndTime').value = 0;
            updateSliderLabels(); 
            setupHotkeyCapture();
            document.getElementById('addModal').style.display = 'block';
        }

        function openEditModal() {
            if (!selectedSound || !config.sounds[selectedSound]) {
                alert('Selecione um som para editar!');
                return;
            }

            const data = config.sounds[selectedSound]; 

            document.getElementById('modalTitle').textContent = 'Editar Som';
            document.getElementById('originalSoundName').value = selectedSound; 
            document.getElementById('soundName').value = selectedSound;
            document.getElementById('soundHotkey').value = data.hotkey;
            document.getElementById('fileName').textContent = path.basename(data.path);
            selectedFilePath = data.path;
            
            loadAudioDuration(selectedFilePath); // <<< MUDAN√áA: Carrega a dura√ß√£o
            
            document.getElementById('soundVolume').value = data.volume !== undefined ? data.volume : 1;
            document.getElementById('soundSpeed').value = data.speed !== undefined ? data.speed : 1;
            document.getElementById('soundLoop').checked = data.loop || false;
            document.getElementById('soundStartTime').value = data.startTime || 0;
            document.getElementById('soundEndTime').value = data.endTime || 0;
            updateSliderLabels(); 
            setupHotkeyCapture();
            document.getElementById('addModal').style.display = 'block';
        }



        function closeAddModal() {
            // --- MUDAN√áA: Para o √°udio de preview se estiver tocando ---
            if (previewAudio) {
                previewAudio.pause();
                previewAudio.src = '';
                previewAudio = null;
                if (previewStopTimer) clearTimeout(previewStopTimer);
                previewStopTimer = null;
            }
            // --- Fim da mudan√ßa ---

            document.getElementById('addModal').style.display = 'none';
            isCapturingHotkey = false;
            capturedKeys.clear();
            selectedFilePath = null;
            document.getElementById('originalSoundName').value = '';
            document.getElementById('audioDuration').textContent = ''; // Limpa a dura√ß√£o
        }

        async function selectFile() {
            const filePath = await ipcRenderer.invoke('select-audio-file');
            if (filePath) {
                selectedFilePath = filePath;
                document.getElementById('fileName').textContent = path.basename(filePath);
                
                // --- MUDAN√áA: Chama a fun√ß√£o para carregar a dura√ß√£o ---
                // E passa um callback para auto-preencher o campo "Fim"
                loadAudioDuration(filePath, (duration) => {
                    const endTimeInput = document.getElementById('soundEndTime');
                    // S√≥ auto-preenche se o valor for 0
                    if (parseFloat(endTimeInput.value) === 0) {
                         endTimeInput.value = duration.toFixed(2);
                    }
                });
            }
        }

        async function saveSound() {
            const name = document.getElementById('soundName').value.trim();
            const hotkey = document.getElementById('soundHotkey').value.trim();
            const originalName = document.getElementById('originalSoundName').value;
            const volume = parseFloat(document.getElementById('soundVolume').value);
            const speed = parseFloat(document.getElementById('soundSpeed').value);
            const loop = document.getElementById('soundLoop').checked;
            const startTime = parseFloat(document.getElementById('soundStartTime').value) || 0;
            const endTime = parseFloat(document.getElementById('soundEndTime').value) || 0;

            if (!name) { alert('Por favor, insira um nome para o som!'); return; }
            if (!hotkey) { alert('Por favor, insira um atalho!'); return; }
            if (!selectedFilePath) { alert('Por favor, selecione um arquivo de √°udio!'); return; }
            
            if (name !== originalName && config.sounds[name]) { 
                alert(`O nome "${name}" j√° est√° em uso. Escolha outro nome.`);
                return;
            }
            
            let stats = { playCount: 0, lastPlayed: null }; // Padr√£o para sons novos

            if (originalName) {
                // √â uma edi√ß√£o, busca stats antigos
                const soundData = config.sounds[originalName];
                if (soundData) {
                    stats.playCount = soundData.playCount || 0;
                    stats.lastPlayed = soundData.lastPlayed || null;
                }
            }

            // --- MUDAN√áA: L√≥gica para atualizar a ordem ---
            if (originalName) {
                // √â uma EDI√á√ÉO
                if (originalName !== name) {
                    // Foi RENOMEADO
                    // 1. Deleta a entrada antiga no objeto
                    delete config.sounds[originalName];
                    // 2. Atualiza o nome no array de ordem
                    const index = config.settings.soundOrder.indexOf(originalName);
                    if (index > -1) {
                        config.settings.soundOrder[index] = name;
                    }
                }
                // (Se o nome for o mesmo, n√£o faz nada na ordem)
            } else {
                // √â um som NOVO
                // 1. Adiciona o nome ao final do array de ordem
                config.settings.soundOrder.push(name);
            }
            // --- Fim da mudan√ßa ---
            
            config.sounds[name] = { 
                path: selectedFilePath,
                hotkey: hotkey,
                volume: volume,
                speed: speed,
                loop: loop,
                startTime: startTime,
                endTime: endTime,
                playCount: stats.playCount,
                lastPlayed: stats.lastPlayed
            };
            
            await saveConfig();
            selectedSound = name; 
            renderSounds();
            closeAddModal();
        }

        async function removeSound() {
            if (!selectedSound) {
                alert('Selecione um som para remover!');
                return;
            }
            if (confirm(`Deseja remover o som "${selectedSound}"?`)) {
                delete config.sounds[selectedSound]; 
                config.settings.soundOrder = config.settings.soundOrder.filter(name => name !== selectedSound);
                await saveConfig();
                selectedSound = null;
                renderSounds();
            }
        }

        function testSelected() {
            if (!selectedSound) {
                alert('Selecione um som para testar!');
                return;
            }
            playSound(selectedSound);
        }

        

        async function playSound(name) {
            const data = config.sounds[name];
            if (!data) return;

            // --- NOVO BLOCO DE C√ìDIGO ---
            // Verifica se o som ATUAL √© o MESMO que foi pedido
            // if (currentAudio && currentPlayingSoundName === name && !currentAudio.paused) {
            //     // √â o mesmo som, e ele est√° tocando. Pare ele.
            //     currentAudio.pause();
            //     currentAudio.currentTime = 0; 
            //     currentAudio.src = ''; // Limpa a fonte
            //     currentAudio = null; // Descarta o √°udio
            //     currentPlayingSoundName = null; // Limpa o nome
                
            //     if (stopAudioTimer) {
            //         clearTimeout(stopAudioTimer);
            //         stopAudioTimer = null;
            //     }
            //     return; // Sai da fun√ß√£o
            // }
            // --- FIM DO NOVO BLOCO ---

            if (currentAudio && currentPlayingSoundName === name && !currentAudio.paused) {
                currentAudio.pause();
                currentAudio.currentTime = 0; 
                currentAudio.src = ''; 
                currentAudio = null; 
                currentPlayingSoundName = null; 
                
                if (stopAudioTimer) {
                    clearTimeout(stopAudioTimer);
                    stopAudioTimer = null;
                }
                
                await restoreVolumeBoost(); // <<< RESTAURA O VOLUME
                return; 
            }

            // Se chegou aqui, ou √© um som diferente, ou nenhum som estava tocando.
            // Pare qualquer som que ESTIVESSE tocando (c√≥digo que j√° existia)
            if (currentAudio) {
                currentAudio.pause();
                currentAudio.currentTime = 0;
                currentAudio.src = ''; 
                currentAudio = null;
            }
            if (stopAudioTimer) {
                clearTimeout(stopAudioTimer);
                stopAudioTimer = null;
            }

            await restoreVolumeBoost();

            try {
                // 1. Inicializa os campos se n√£o existirem
                if (data.playCount === undefined || isNaN(data.playCount)) {
                    data.playCount = 0;
                }
                
                // 2. Incrementa e atualiza
                data.playCount++;
                data.lastPlayed = new Date().toISOString(); // Formato padr√£o ISO

                // 3. Salva a configura√ß√£o (sem re-renderizar, playSound n√£o deve fazer isso)
                await saveConfig();
            } catch (err) {
                console.error('Erro ao salvar estat√≠sticas:', err);
            }
            
            // Toca o novo som
            try {
                await applyVolumeBoost();

                currentAudio = new Audio(data.path);
                currentPlayingSoundName = name; // <<< NOVO: Guarda o nome do som atual

                const startTime = data.startTime || 0;
                const endTime = data.endTime || 0;

                currentAudio.volume = data.volume !== undefined ? data.volume : 1;
                currentAudio.playbackRate = data.speed !== undefined ? data.speed : 1;
                currentAudio.loop = data.loop || false;
                currentAudio.currentTime = startTime;

                // <<< NOVO: Limpa o nome quando o √°udio terminar sozinho
                currentAudio.addEventListener('ended', () => {
                    currentPlayingSoundName = null;
                });

                const deviceId = config.settings.audioDevice || 'default';
                if (deviceId !== 'default') {
                    try {
                        await currentAudio.setSinkId(deviceId);
                    } catch (err) {
                        console.error('Falha ao definir a sa√≠da de √°udio:', err);
                        alert('Erro! N√£o foi poss√≠vel alterar a sa√≠da de √°udio. Voltando para o Padr√£o.');
                        config.settings.audioDevice = 'default';
                        document.getElementById('audioOutputSelect').value = 'default';
                        await saveConfig();
                    }
                }

                currentAudio.play().catch(err => {
                    console.error('Erro ao reproduzir √°udio:', err);
                    alert('Erro ao reproduzir o √°udio. Verifique se o arquivo existe.');
                    currentAudio = null;
                    currentPlayingSoundName = null;
                    restoreVolumeBoost();
                });

                // L√≥gica do temporizador (endTime)
                if (endTime > startTime && !currentAudio.loop) {
                    const durationInMs = (endTime - startTime) * 1000 / currentAudio.playbackRate;
                    stopAudioTimer = setTimeout(() => {
                        // NOVO: Verifica se ainda √© o som certo antes de parar
                        if (currentAudio && currentPlayingSoundName === name) { 
                            currentAudio.pause();
                            currentAudio.currentTime = startTime;
                            currentPlayingSoundName = null;
                            restoreVolumeBoost();
                        }
                    }, durationInMs);
                }

                if (endTime > startTime && currentAudio.loop) {
                    currentAudio.addEventListener('timeupdate', function() {
                        if (this.currentTime >= endTime) {
                            this.currentTime = startTime;
                        }
                    });
                }

            } catch (error) {
                console.error('Erro ao criar Audio:', error);
                alert('Erro ao carregar o √°udio.');
                currentAudio = null;
                currentPlayingSoundName = null;
                restoreVolumeBoost();
            }
        }

        ipcRenderer.on('get-sound-list', () => {
            // const soundNames = Object.keys(config.sounds);
            
            // ipcRenderer.send('sound-list', soundNames);

            const orderedSoundNames = config.settings.soundOrder || [];
            ipcRenderer.send('sound-list', orderedSoundNames);
        });

        ipcRenderer.on('play-sound', (event, name) => {
            playSound(name); 
        });

        window.onclick = function(event) {
            const modal = document.getElementById('addModal');
            if (event.target === modal) {
                closeAddModal();
            }
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && document.getElementById('addModal').style.display === 'block') {
                if (!isCapturingHotkey) {
                    saveSound();
                }
            }
            if (e.key === 'Escape') {
                closeAddModal();
            }
        });

        function setupHotkeyCapture() {
            const hotkeyInput = document.getElementById('soundHotkey');
            
            hotkeyInput.addEventListener('focus', () => {
                isCapturingHotkey = true;
                capturedKeys.clear();
                hotkeyInput.value = '';
                hotkeyInput.placeholder = 'Pressione as teclas...';
            });
            
            hotkeyInput.addEventListener('blur', () => {
                isCapturingHotkey = false; 
                if (hotkeyInput.value === '') {
                    hotkeyInput.placeholder = 'Clique aqui e pressione as teclas...';
                }
            });
        }

        document.addEventListener('keydown', (e) => {
            const hotkeyInput = document.getElementById('soundHotkey');
            
            if (isCapturingHotkey && document.getElementById('addModal').style.display === 'block') {
                e.preventDefault();
                
                if (['Control', 'Shift', 'Alt'].includes(e.key)) {
                    return;
                }
                
                const keys = [];
                
                if (e.ctrlKey) {
                    keys.push('CommandOrControl');
                }
                if (e.shiftKey) {
                    keys.push('Shift');
                }
                if (e.altKey) {
                    keys.push('Alt');
                }
                
                let key = e.key;
                
                const specialKeys = {
                    ' ': 'Space', 'ArrowUp': 'Up', 'ArrowDown': 'Down',
                    'ArrowLeft': 'Left', 'ArrowRight': 'Right', 'Escape': 'Esc'
                };
                
                if (specialKeys[key]) {
                    key = specialKeys[key];
                } else if (key.length === 1) {
                    key = key.toUpperCase();
                }
                
                if (!['CONTROL', 'SHIFT', 'ALT'].includes(key.toUpperCase())) {
                     keys.push(key);
                }
               
                const hotkey = keys.join('+');
                hotkeyInput.value = hotkey;
                
                setTimeout(() => {
                    isCapturingHotkey = false;
                    hotkeyInput.blur();
                }, 100);
            }
        });

        function clearHotkey() {
            document.getElementById('soundHotkey').value = '';
            capturedKeys.clear();
        }

        const notification = document.getElementById('notification');
        const message = document.getElementById('notificationMessage');
        const restartButton = document.getElementById('restartButton');

        ipcRenderer.on('update-available', () => {
          ipcRenderer.removeAllListeners('update-available');
          message.innerText = 'Uma nova atualiza√ß√£o est√° sendo baixada...';
          notification.classList.add('show');
        });

        ipcRenderer.on('update-downloaded', () => {
          ipcRenderer.removeAllListeners('update-downloaded');
          message.innerText = 'Atualiza√ß√£o pronta! Reiniciar agora para instalar?';
          restartButton.style.display = 'flex'; // Mostra o bot√£o
          notification.classList.add('show');
        });

        function restartApp() {
          ipcRenderer.send('restart-app');
        }
        loadConfig();

        function formatLastPlayed(isoString) {
            if (!isoString) {
                return 'Nunca';
            }
            try {
                const date = new Date(isoString);
                const now = new Date();
                
                // Zera as horas para comparar apenas os dias
                const today = new Date();
                today.setHours(0, 0, 0, 0);

                const yesterday = new Date();
                yesterday.setDate(yesterday.getDate() - 1);
                yesterday.setHours(0, 0, 0, 0);

                const dateToCompare = new Date(date.getTime());
                dateToCompare.setHours(0, 0, 0, 0);

                const time = date.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });

                if (dateToCompare.getTime() === today.getTime()) {
                    return `Hoje, ${time}`;
                }
                if (dateToCompare.getTime() === yesterday.getTime()) {
                    return `Ontem, ${time}`;
                }
                return date.toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit', year: 'numeric' });

            } catch (e) {
                return 'Data inv√°lida';
            }
        }

        navigator.mediaDevices.ondevicechange = (event) => {
            console.log('Dispositivos de m√≠dia mudaram! Recarregando lista de √°udio...');
            
            const select = document.getElementById('audioOutputSelect');
            const valorAntigo = select.value;

            loadAudioDevices().then(() => {
                if (Array.from(select.options).some(opt => opt.value === valorAntigo)) {
                    select.value = valorAntigo;
                } else {
                    select.value = 'default';
                    saveAudioDevice();
                }
            });
        };
    </script>
</body>
</html>